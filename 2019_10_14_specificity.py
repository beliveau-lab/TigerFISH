"""
Robin Aguilar
Beliveau and Noble Labs, 10/14/2019
Dependencies: N/A
Input: Probe file, Jellyfish file, index file
Output: A .bed file of probes that pass probe binding score in the form of a DF 
"""

#import all functions/modules needed
import time
import io
import sys
import re
import csv
import argparse
from collections import defaultdict
from itertools import islice
from operator import itemgetter, attrgetter
import subprocess
import numpy as np
import pandas as pd
import glob
import os
import refactoredBlockparse as bp
from Bio.SeqUtils import MeltingTemp as mt
from Bio.Seq import Seq
from Bio.Alphabet import IUPAC
from Bio.SeqUtils import GC
from Bio import SeqIO
from itertools import groupby
from Bio.Alphabet import generic_dna, generic_protein
from scipy import signal
import time
from collections import OrderedDict
import collections
from operator import itemgetter
from itertools import groupby
from collections import Counter
import itertools

#declare a timer
start_time=time.time()

#include user arguments
userInput = argparse.ArgumentParser(description=\
        '%Requires a FASTA file as input. And Jellyfish Index file of genome '
        'single-entry or multi-lined FASTA files are supported.  Returns a dataframe which '
        'can be used for further parsing with probe information.')

requiredNamed = userInput.add_argument_group('required arguments')
requiredNamed.add_argument('-p', '--probe_file', action='store', required=True,
                               help='The FASTA file to find probes in')
requiredNamed.add_argument('-j', '--jf_file', action='store', required=True,
                               help='The kmer query file from jellyfish')
requiredNamed.add_argument('-k', '--idx_file', action='store', required=True,
                               help='The kmer query file from jellyfish')
args = userInput.parse_args()
test_probes=args.probe_file
test_jf=args.jf_file
k_index_f=args.idx_file

#variable for length of kmer (will be an argument in repeat_ID script)
MERLENGTH=18

def probe_df(probe_f,repeat_f):
    """
    This function will organize the format of the dataframe containing all probe information. It takes the probe file, names
    the columns, then puts the probes into a list.
    """
    probe_data=pd.read_csv(probe_f, delimiter = '\t',names=["index","p_start","p_end","probe_seq","Tm","region"])
    probe_data['region'] = probe_data['region'].astype(str)

    probe_data[['chr','r_start','r_end']] = probe_data.region.str.replace(":","-").str.split("-",expand=True)

    probe_data['r_start']=probe_data['r_start'].astype(int)
    probe_data['r_end']=probe_data['r_end'].astype(int)

    #here, probe sequences are appended to a list
    probe_seqs = probe_data['probe_seq'].tolist()

    return probe_data,probe_seqs

indexList=[]
merWindows_lengths=[]

def probe_index(probe_seq_l):
    """
    This function will make a list that contains how many indices each probe sequence in 18mers will span
    ex) a probe sequence of some length, when decomposed into 18mers, is x indices in length
    """
    for i in range(0, len(probe_seq_l), 1):
        probeLength = len(probe_seq_l[i])
        merWindows = probeLength - MERLENGTH + 1
        merWindows_lengths.append(merWindows)
    return merWindows_lengths
   
def append_probe_windows(probe_data_df,merlengths,k_index):
    """
    This function will add the lengths of the probe windows to the probe data DF. This will find the indices of where the 
    repeat regions are located in the kmer query file generated by jellyfish. The indices to parse the jellyfish file are
    appended as columns called test_start_idx and test_end_idx. The computation for the true probe start and end indices is
    also appended to the DF.
    """

    probe_data_df['probe_dist']=merlengths

    #read the indices from the file and add to a list
    kmer_indices=[]
    with open(k_index,"r") as index_file:
        kmer_indices=[int(line) for line in index_file]

    probe_start_indices = probe_data_df['r_start'].tolist()
    probe_end_indices = probe_data_df['r_end'].tolist()

    #based on the repeat start and ends, identify what index these values are located at
    sections=[]
    starts=[kmer_indices.index(int(start)) for start in probe_start_indices]
    ends=[kmer_indices.index(int(end)) for end in probe_end_indices]

    #add these list values to the DF
    probe_data_df['test_start_idx']=starts
    probe_data_df['test_end_idx']=ends

    #also add new columns for the probe start and end start
    probe_data_df['test_p_start']=probe_data_df['test_start_idx'].astype(int)+probe_data_df['p_start']
    probe_data_df['test_p_end']=probe_data_df['test_p_start'].astype(int)+probe_data_df['probe_dist']

    return probe_data_df

max_list_region=[]
max_list_all=[]
k_mer=[]
float_count=[]

def get_max_hg_repeat(jf_file,probe_data_df):
    """
    This function will iterate through probe_data_df DF and get the max count for probes in the genome and in the repeat region
    the probe was designed against.
    """
    #read the jellyfish file and add the k_mers and the associated counts into individual lists
    with open(jf_file,"r") as jf:
        for line in jf:
            k_mer.append(line.split()[0])
            float_count.append(float(line.split()[1]))

    #iterate through the dataframe containing all probe information, repeat start/end, probe start/end
    for row in probe_data_df.itertuples():
        probes=row.probe_seq
        r_start=row.test_start_idx
        r_end=row.test_end_idx
        p_start=row.test_p_start
        p_end=row.test_p_end

        #obtain max value for each probe in all of hg38, use -1 to adjust indices, take max of list for each probe
        probe_kmers_count=(float_count[int(p_start)-1:int(p_end)-1])
        max_list_all.append(max(probe_kmers_count))

        #obtain max value a all 18mers exists in each repeat region/probe
        #takes the repeat k-mers and adds them to a counter
        repeat_kmers=(k_mer[int(r_start):int(r_end)])
        region_kmers=Counter(repeat_kmers)
        
        #obtain a list of all k-mers in the probe sequence
        probe_kmers_seqs=(k_mer[int(p_start)-1:int(p_end)-1])

        #checks to see if an item in the probe_kmer seqs list is also found as a key in the Counter for all k-mers in repeat
        region_vals=[region_kmers[item] for item in probe_kmers_seqs if item in region_kmers]

        #returns the max value for each of those kmers
        largest=max(region_vals)
        max_list_region.append(largest)
        
    #appends the max list in HG as a column
    probe_data_df['max_mer_list']=max_list_all
    
    #appends the max list in repeat as a column
    probe_data_df['max_repeat']=max_list_region
    
    #computes a new column for the probe binding score
    probe_data_df["k-mer enrich"]=probe_data_df['max_repeat'].astype(int)/(probe_data_df['max_mer_list'].astype(int))

    #filters to remove probes that don't pass thresholds
    probe_data_df=probe_data_df[(probe_data_df['k-mer enrich'] >= 0.50) & (probe_data_df['max_repeat'] >= 10)]
    
    #generates a file probe file containing filtered results
    probe_data_df.to_csv('probes_final_score.txt', header=False, index=False, sep="\t")

    return probe_data_df

def main():

    probe_data,probe_seqs=probe_df(test_probes,repeat_f)

    print("---%s seconds ---"%(time.time()-start_time))

    merWindows_lengths=probe_index(probe_seqs)

    print("---%s seconds ---"%(time.time()-start_time))

    probe_data_df=append_probe_windows(probe_data,merWindows_lengths,k_index_f)

    print("---%s seconds ---"%(time.time()-start_time))

    get_max_hg_repeat(test_jf,probe_data_df)

    print("---%s seconds ---"%(time.time()-start_time))

    print("Done")

if __name__== "__main__":
    main()




