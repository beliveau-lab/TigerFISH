Command Line Interface
######################

`Tigerfish` was written by Robin Aguilar while in the Department of Genome Sciences at the University of Washington.

Official code website:

The `Tigerfish` workflow is managed by Snakemake which is used to scale and automatically deploy pipeline jobs in parallel as described in our getting started page.

Essentially, each script in the Tigerfish workflow has a set of parameters that may be modified by users. Each script in the main workflow implements these parameters which are called from the pipeline's config.yml file. As a user, one would only need to modify arguments from the config.yml file in order to get Tigerfish working. Named arguments for each script are defined in detail below. Recommended default parameters are also provided that were used for probe mining in the latest version of the CHM13 genome.  

Named Arguments in config.yml for main workflow
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**fasta_file**: File path. The genomic reference file used for probe design. Should includes all scaffolds of interest in the provided genome in proper FASTA format.

**chrom_sizes_file**: File path. The chromosome sizes file containing all scaffolds and scaffold lenths. Take care to make sure **fasta_file** and **chrom_sizes_file** reflect the same genomic version to avoid unexpected behavior.

**defined_coords**: Boolean flag. If marked as **TRUE** a BED file path must be provided for the **bed_file** parameter. If parameter is not being used, it should be toggled to **FALSE**.

**bed_file**: Optional file path if Boolean = TRUE for **defined_coords**. This BED file should contain tab seperated positional information (chrom, start, stop) for a target repeat region of interest.

**repeat_discovery**: Boolean flag. If marked as **TRUE**, Tigerfish will be implemented to search for repeat specific chromosomes along select scaffolds or the entire geome as long as scaffold names are listed in the **samples** parameter. If **defined_coords** is being used instead, toggle **repeat_discovery** = **FALSE**. 

**assembly**: String. The name of the genome assembly being used.

**samples**: String. Described as sample in config.yml file. Each sample can be one or more scaffolds present in a given genome. Scaffold names should match FASTA file headers.

Example format in config.yml:

sample:
    - "chr1"
    - "chr2"

Example format in FASTA file:

>chr1
seq1
>chr2
seq2

**threshold**: Integer. `Tigerfish` identifies regions of elevated k-mer counts where these integers are binarized using a user-specified threshold. K-mer counts are computed using Jellyfish. If k-mer counts are >= to this threshold value, they will be assigned a value of 1 while all others receive a 0. This value is only used if **repeat_discovery** is invoked.   

**window**: Integer. `Tigerfish` applies a sliding window, along the binary vector generated by the applied **threshold** parameter, yielding for each position a count from 0 to the length of the window. This value is only used if **repeat_discovery** is invoked.

**composition**: Float. `Tigerfish` take the counts within each **window** so that they are divided by the window width to yield a normalized count at each base pair where `Tigerfish` then identifies contiguous regions of the genome in which this normalized count exceeds this defined composition score. This value is only used if **repeat_discovery** is invoked.

**file_start**: Integer. The start location of where `Tigerfish` makes a 1:1 mapping of the first base of all reported k-mers from the Jellyfish k-mer count output.

**min_length**: Integer. The minumum length of any possible designed oligo probe. 

**max_length**: Integer. The maximum length of any possible designed oligo probe. 

**min_temp**: Integer. The minimum melting temperature of any possible designed oligo probe.

**max_temp**: Integer. The maximum melting temperature of any possible designed oligo probe. 

**mer_val**: Integer. The k-mer size used to generate Jellyfish hash tables, index files, and for sequence k-mer comparison during filtering analysis.

**enrich_score**: Float. Given the nature of probes designed against repetitive sequences, first it is important to filter probes with low on-target repeat binding based on the aggregate count of a probeâ€™s k-mers within a given repeat target and within the entire human genome. Here, we describe this score as an **enrich_score** which is the sum of all 18-mers derived from a given probe sequence within a repeat target (Rm) over the sum of 18-mers in a given probe sequence within the entire human genome (Rm/Hm). Only probes with an enrich_score >= to the proportion provided are kept. 

**copy_num**: Integer. Each designed candidate oligo probe is broken down into it's respective k-mer length using the **mer_val** parameter. Here, the total count of all k-mers for each probe within the probe's target repeat region defines the **copy_num** parameter. Here, this value may be set so that only probes with a value >= **copy_num** will be advance to further downstream filtering. 

**c1_val** and **c2_val**: Integer. After preliminary filtering based on target binding specificity, remaining probes within each target repeat are ranked in descending order using a normalization value composed of two constants **c1_val** and **c2_val**. This equation can be described as normalized rank = ((**copy_num**/max **copy_num** value within each target repeat) * **c1_val**) + ((**enrich_score**/max **enrich_score** value within each target repeat) * **c2_val**). These two values may be toggled to determine a rank order to control whether it's preferred to rank probes based on their **copy_number** value or **enrich_score**.

**genome_windows**: Integer. All provided genome scaffolds are binned into windows of this size.  

**target_sum**: Integer. `Tigerfish` will add candidate probes based on if their on-target binding score satisfies the **min_on_target** parameter. Candidate probes will be added to the final collection until this **target_sum** is satisfied or no other probe candidates are available. 

**off_bin_thresh**: Float. Using the **genome_windows** parameter, predicted thermodynamic binding scores are aggregated over the genomic bins that each probe alignment maps too. Should any one of these bins that doesn't map to the target have a value >= the provided **off_bin_thresh**, that probe will be culled due to the likelihood that it will bind to an additional repeat target in the genome.

**binding_prop**: Float. Using the **genome_windows** parameter, predicted thermodynamic binding scores are aggregated over the genomic bins that each probe alignment maps too. Here, the alignments that occur within the bin(s) mapping to the repeat target are defined as on-target bins whereas all binding events elsewhere are considered off-target bins. This **binding_prop** is the proportion of on-target binding scores/all total binding events.  

**mer_cutoff**: Float. To remove redundant probes, all candidate probes at this step are broken down into their respective k-mers based on the **mer_val** parameter after they are rank ordered. Should any probes have a **mer_cutoff** >= to the provided value, it will be culled due to k-mer similar to a probe that was ranked above it. 

**bt2_alignments**: Integer. The maximum number of alignmnts to be returned by Bowtie2 for any particular oligo probe. 

**max_pdups_binding**: Float. As probes are stored in the final collection of candidate repeat probes following throrough genomic alignment, we check to see if valid probes will not form secondary structure with one another. We do this in the event that multiple candidate probes from the same genomic target may form secondary structure with one another. Therefore, we compute NUPACK predicted duplexing probabilities between all valid candidate probe sequences to cull those with binding scores >= the  **max_pdups_binding** value provided. This proportion must exist on a scale of 0 - 1.  

**seed_length**: Integer. `Tigerfish` implements Bowtie2 to align remaining probes to the entire queried genome to ensure that probes will not bind to unexpected binding sites. As described by Bowtie2, there is a tradeoff between speed and sensitivity/accuracy that can be adjusted by setting the seed length, which is the interval between extracted seeds. 

**model_temp**: Float. `Tigerfish` implements NUPACK to compute the predicted thermodynamic likelihood that each alignment pair will form duplexes under FISH conditions. The temperature parameter for this model can be modified as a parameter. 

**min_on_target**: Integer. Minimum aggregate on target binding score based on thermodynamic binding predictions derived from NUPACK across all returned genomic alignments. 

**max_probe_return**: Integer. The maximum total number of probes to be returned (if found) that satisfied final pipeline filtering and parameters. 


Table of default parameters
^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following table summarizes parameters used to design and search for repeat specific probes in the fully assembled CHM13 human genome assembly. We would recommend these settings as default parameters depending on the use case. The first column presents a more strict high copy repeat probe search that primarily focuses on searching for large rpeetitive probe arrays that predominantly map to alpha satellite and human satellite repeats. The other two columns present more flexible parameters that will provide many diverse repeat target types including some smaller repeat families such as LINES/SINES, LTRs, etc including larger satellite DNA arrays. 

We also share that these parameters may *not* equally map across genome size. For smaller genomes (mouse, fly, etc.) we recommend decreasing window size to ensure that the window is smaller than that of the smallest scaffold present in the genome assembly if performing repeat identification. Further resources on repeat probe design in model organism genomes is in development. 


.. list-table:: Default parameters used to mine repeat specific oligo probes in the CHM13 human genome assembly
   :header-rows: 1

   * - Parameter
     - Strict high copy repeat probe search mode
     - Flexible repeat probe search mode
     - Panel featured in Tigerfish paper      
   * - threshold
     - 5
     - 5
     - 5
   * - window
     - 4000
     - 4000
     - 4000
   * - composition
     - 0.25
     - 0.25
     - 0.25
   * - file_start
     - 0
     - 0
     - 0
   * - min_length
     - 25
     - 25
     - 36
   * - max_length
     - 50
     - 50
     - 41
   * - min_temp
     - 42
     - 42
     - 42
   * - max_temp
     - 52
     - 52
     - 47
   * - mer_val
     - 18
     - 18
     - 18
   * - enrich_score
     - 0.80
     - 0.70
     - 0.50
   * - copy_num
     - 100
     - 40
     - 10
   * - c1_val
     - 1
     - 1
     - 1
   * - c2_val
     - 5
     - 5
     - 5
   * - genome_windows
     - 5000000
     - 5000000
     - 5000000
   * - target_sum
     - 20000
     - 20000
     - 20000
   * - off_bin_thresh
     - 100
     - 100
     - 100
   * - binding_prop
     - 0.70
     - 0.70
     - 0.70
   * - mer_cutoff
     - 0.95
     - 0.95
     - 0.95
   * - bt2_alignment
     - 500000
     - 500000
     - 500000
   * - max_pdups_binding
     - 0.90
     - 0.90
     - 0.90
   * - seed_length
     - 15
     - 15
     - 15
   * - model_temp
     - 69.5
     - 69.5
     - 69.5
   * - min_on_target
     - 500
     - 25
     - 25
   * - max_probe_return
     - 25
     - 20
     - 40

Main workflow
^^^^^^^^^^^^^

Here is a simplified DAG of how Snakemake implements scripts in the Tigerfish workflow:

.. image:: imgs/snakemake.svg
   :width: 400
   :alt: A picture of a DAG of the Tigerfish workflow


The scripts below are presented in the order that they are executed by the `Tigerfish` workflow via Snakemake. Here, all scripts and their function are documented to better understand the workflow, which files are generated at each snakemake step, and where config parameters are called. 

generate_jf_count
-----------------

Purpose: Generates a Jellyfish index file that is used for counting k-mers downstream.

Input: Genome reference FASTA file

Output: A genome query hash file containing counts of all k-mers in the form of a .jf file. 

.. code-block:: bash

   jellyfish count -s 3300M -m {params.mer_val} -o {output} {input.fasta_file}


**config.yml parameters**

* mer_val
* fasta_file

**Snakemake parameters**

* {output}



generate_bt2_indices
------------------

Purpose: Generates genome Bowtie2 indices which is used for aligning probes to the entire genome of interest.

Input: Genome reference FASTA file

Output: Collection of Bowtie2 indices placed in a Bowtie2 directory of your choosing.

.. code-block:: bash

   bowtie2-build --threads 4 {input} {BOWTIE2_DIR}/{ASSEMBLY}

**config.yml parameters**

* {input}

**Snakemake parameters**

* {BOWTIE2_DIR}/{ASSEMBLY}



generate_jf_idx
-----------------

Purpose: To generate k-mer count index files using the derived jellyfish hash table from the `generate_jf_count` step. Generates independent k-mer count index files for each scaffold. 

Inputs: Genome reference FASTA file (FASTA_FILE). Output Jellyfish hash table generated from the `generate_jf_count` step (JF_INDEXFILE)

Outputs: An output jellyfish k-mer count file containing all k-mers within a selected scaffold and it's corresponding counts (JF_OUT). A file that is used to reference the base position of where the start of each k-mer in the output count file occurs (J_INDEX_OUT). A seperated FASTA file of each selected scaffold (SCAFFOLD_FA_OUT).

.. code-block:: bash

    usage: generate_jf_idx.py [-h] -f FASTA_FILE -j JF_INDEXFILE -c CHR_NAME -f_o
                          SCAFFOLD_FA_OUT -j_o JF_OUT -i J_INDEX_OUT -m
                          MER_VAL

**config.yml parameters**

* fasta_file
* sample (CHR_NAME)
* mer_val (MER_VAL)

**Snakemake parameters**

* JF_INDEXFILE (`generate_jf_count` output)
* SCAFFOLD_FA_OUT
* JF_OUT
* J_INDEX_OUT



split_bed
---------

Purpose:

Inputs:

Outputs:

.. code-block:: bash

   usage: split_bed.py [-h] -b BED_FILE -c CHROM_NAME -o BED_OUT

**config.yml parameters**

**Snakemake parameters**





repeat_ID
---------

Purpose: 
Input:
Output:
 
.. code-block:: bash

    usage: repeat_ID.py [-h] -j JF_COUNT -i INDEX_FILE -chr CHR_NAME -st START
                    [-w WINDOW_LENGTH] [-t THRESHOLD] [-c COMPOSITION_SCORE]
                    -o_b BED_FILE -m MER_LENGTH

**config.yml parameters**


design_probes
-------------

Purpose:
Input:
Output:

.. code-block:: bash

   usage: design_probes.py [-h] -b BED_NAME -r_o REGION_OUT -p_o PROBES_OUT -g
                        GENOME_FASTA -c CHROM_NAME -l MIN_LEN -L MAX_LEN -t
                        MIN_TEMP -T MAX_TEMP

**config.yml parameters**

kmer_filter
-----------

Purpose:
Input:
Output:

.. code-block:: bash

   usage: kmer_filter.py [-h] -p PROBE_FILE -j JF_FILE -f FASTA [-m MERLENGTH] -o
                      OUT_PATH -c1 C1_VALUE -c2 C2_VALUE

**config.yml parameters**

probe_mer_filter
----------------

Purpose:
Input:
Output"

.. code-block:: bash

   usage: probe_mer_filter.py [-h] -f FILE_PATH -o OUT_PATH -e ENRICH_SCORE -cn
                           COPY_NUM -m MER_CUTOFF -k MERLENGTH

**config.yml parameters**


generate_genome_bins
--------------------

Purpose:
Input:
Output:

.. code-block:: bash

   bedtools makewindows -g {input.sizes} -w {params.window} > {output}

**config.yml parameters**

alignment_filter
----------------

Purpose:
Input:
Output:

.. code-block:: bash

   usage: alignment_filter.py [-h] -f PROBE_FILE -o OUT_FILE
                           [-r REGION_THRESHOLD] -b BOWTIE_INDEX -k
                           BT2_MAX_ALIGN -l SEED_LENGTH -t MODEL_TEMP -pb
                           MAX_PDUPS_BINDING -moT MIN_ON_TARGET -Mr
                           MAX_PROBE_RETURN -gb GENOMIC_BIN -th THRESH

**config.yml parameters**


gather_repeat_regions
---------------------

Purpose:
Input:
Output:

.. code-block:: bash

   usage: split_filter.py [-h] -f FILE_PATH -o OUT_PATH

**config.yml parameters**

summary
-------

Purpose:
Input:
Output:

.. code-block:: bash

   usage: finish_summary.py [-h] -f PROBE_FILE -o OUT_FILE

**config.yml parameters**


Post-process Workflow
^^^^^^^^^^^^^^^^^^^^^

The scripts below are presented in the order that they are executed by the `Tigerfish` workflow via Snakemake. Here, all scripts and their function are documented to better understand the workflow, w
hich files are generated at each snakemake step, and where config parameters are called.

bin_genome
----------

Purpose
Input:
Output:

.. code-block:: bash

   bedtools makewindows -g {input.sizes} -w {params.window} > {output}

**config.yml parameters**



gather_repeat_regions
---------------------

Purpose:
Input:
Output:

.. code-block:: bash

   split_filter_region.py [-h] -f FILE_PATH -o OUT_PATH -c CHROM


**config.yml parameters**



align_probes
------------

Purpose:
Input:
Output:

.. code-block:: bash

   usage: generate_alignments.py [-h] -f FILE_PATH -o OUT_PATH -b BOWTIE_INDEX -k
                              BT2_MAX_ALIGN -l SEED_LENGTH -t MODEL_TEMP

**config.yml parameters**



derived_beds
------------

Purpose:
Input:
Output:

.. code-block:: bash

   usage: make_derived_beds.py [-h] -f FILE_PATH -o OUT_PATH

**config.yml parameters**



get_region_bed
--------------

Purpose:
Input:
Output:

.. code-block:: bash

   usage: get_region_bed.py [-h] -i IN_FILE -o OUT_FILE

**config.yml parameter**



bedtools_intersect
------------------

Purpose:
Input:
Output:

.. code-block:: bash
   "bedtools intersect -wa -wb -a {input.derived_bed} -b {input.genome_bin} > {output.alignments_out} |"
   "bedtools intersect -wa -wb -a {input.repeat_bed} -b {input.genome_bin} > {output.repeat_out}"

**config.yml parameters**



get_alignments
--------------

Purpose:
Input:
Output

.. code-block:: bash

   usage: get_alignments.py [-h] -c_t CHROM_TRACK -c_o CHROM_OVERLAPS -r_o
                         REPEAT_OVERLAP -p PAIRWISE_PDUPS -pl OUT_PLOT -t
                         THRESH -t_s THRESH_SUMM -c_s CHROM_SUMM

**config.yml parameters**



summarize_probe_binding
-----------------------

Purpose:
Input:
Output

.. code-block:: bash

   usage: pipeline_alignment_check.py [-h] -f PROBE_FILE -o OUT_FILE -b
                                   BOWTIE_INDEX -k BT2_MAX_ALIGN -l
                                   SEED_LENGTH -t MODEL_TEMP


**config.yml parameter**



generate_plots
--------------

Purpose:
Input:
Output:

.. code-block:: bash

   usage: generate_bins_plots.py [-h] -c_t CHROM_TRACK -c_o CHROM_OVERLAPS -p
                              PAIRWISE_PDUPS -pl OUT_PLOT

**config.yml parameters**



generate_chromomap
------------------

Purpose:
Input:
Output:

.. code-block:: bash

   usage: Rscript --vanilla make_chromomap.R -c {input.chrom_sizes} -r {input.probe_bed} -o {output}

**config.yml parameters**



If you have more questions about any scripts in particular from the main workflow or post process workflow, be sure to check out our GitHub page. Also check out our `Tigerfish` tutorial to see how these scripts come together to generate example data.




